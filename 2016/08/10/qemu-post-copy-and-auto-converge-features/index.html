<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title>QEMU: Post-Copy and Auto-Converge features &middot; Vlad&#39;s #dev blog</title>
    <meta name="author" content="Vlad Nikityuk">
    <meta name="description" content="Your description of the blog">
    <meta name="generator" content="Hugo 0.17-DEV" />
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- RSS autodiscovery -->
    

    <link rel="shortcut icon" href="https://rk4n.github.io/img/favicon.ico">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/normalize/2.1.2/normalize.min.css">

    <!-- Stylesheets -->
    <link rel="stylesheet" href="https://rk4n.github.io/css/screen.css">
    <link rel="stylesheet" href="https://rk4n.github.io/css/github.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/styles/default.min.css">

    <!-- Stylesheet for theme color -->
    <style type="text/css">
    a, a:visited {color: #3498db;}
    .pagination a {color: #3498db;}
    .gist .gist-file .gist-meta a:visited {color: #3498db !important;}
    a:focus, a:hover {color: #2079b4;}
    h1.post-title a:focus, h1.post-title a:hover, h1.blog-title a:focus, h1.blog-title a:hover {color: #2079b4;}
    .older-posts:hover, .newer-posts:hover {color: #2079b4;}
</style>
</head>

<body class="post-template">

    <header id="site-head">
	
	<h1 class="blog-title"><a href="https://rk4n.github.io/">Vlad&rsquo;s #dev blog</a></h1>
	
	
	<h1 class="blog-subtitle">place for thoughts about tech</h1>
	
</header>
    
<nav class="menu" role="nav">
    <ul>
        
        	<li class="nav nav-current"><a href="/">Home</a></li>
      	
        	<li class="nav nav-current"><a href="/about/">About</a></li>
      	
    </ul>
</nav>


    <main class="content" role="main">
	    <article class="post">
	        <header>
	        <h1 class="post-title">QEMU: Post-Copy and Auto-Converge features</h1>
	        <div class="post-meta"><time datetime="10 August 2016">10 August 2016</time></div>
	        </header>

	        <section class="post-content">
	            

<h2 id="introduction">Introduction</h2>

<p>Cloud life-cycle is a complex process that involves several procedures such as maintenance performing and upgrades. These operations mostly include migration of workloads. OpenStack provides several options to perform such moving:</p>

<ul>
<li>Cold migration</li>
<li>Live migrations</li>
<li>Instance rebuilds</li>
</ul>

<p>From the list above only live migration allows moving an instance from one host to another with almost zero downtime, which is done seamlessly  for the instance itself.</p>

<p>In one of our previous researches we&rsquo;ve noticed that, by default, QEMU/KVM live migration has a pretty low convergence rate for heavy-loaded virtual machines.</p>

<p>In this post, we&rsquo;re going to analyze different QEMU features that may help live migrations converge. The most important features are Post-Copy and Auto-Converge.</p>

<p>The idea behind auto-converge is pretty simple — by throttling down the virtual CPU execution time, the guest machine is prevented from dirtying memory faster than memory can be transferred over the wire. By default, QEMU throttles vCPU by 20% and increases throttling rate by 10% each iteration. This guarantees the that guest machine eventually migrates.</p>

<p>The goal of post-copy is to transfer some portion of memory in normal pre-copy mode, then switch the guest to the destination node and request any missing memory pages on demand. This comes with the additional cost of waiting for a particular page to transfer from the source node, however, post-copy guarantees that guest migrates in a constant amount of time. The downside of using post-copy is that if the destination node fails or there is a network interruption, it becomes impossible to recover the guest machine state as it is distributed between the source and destination nodes.</p>

<p>We wanted to answer the following questions:</p>

<ol>
<li>How do various parameters of the post-copy and auto-converge features affect the migration outcome?</li>
<li>Does the migration <code>max_downtime</code> parameter have any impact on migration success?</li>
</ol>

<h2 id="test-harness">Test Harness</h2>

<h3 id="test-environment">Test Environment</h3>

<p>Our setup consists of two hypervisor nodes and one monitoring VM. The monitoring VM is running on a separate machine. Tests are executed from a workstation which is connected to same network as monitoring VM and hypervisor machines.</p>

<p>All servers have the same configuration:</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>CPU</td>
<td>1x CPU Intel Xeon E3-1230, 3.20GHz, Socket 1155, 8MB Cache, 4 core, 80W</td>
</tr>

<tr>
<td>RAM</td>
<td>4x RAM 4GB Kingston KVR1333D3E9S/4GHB, DDR-III PC3-10600</td>
</tr>

<tr>
<td>Hard drive</td>
<td>2x HDD 1.5 TB, WD Caviar Black, WD1502FAEX, SATA 6.0 Gb/s, 7200 RPM, 64MB, 3.5”</td>
</tr>

<tr>
<td>Network</td>
<td>1x NIC AOC-CGP-i2, PCI-E x4, 2-port Gigabit Ethernet LAN</td>
</tr>
</tbody>
</table>

<p>Software versions:</p>

<ul>
<li>Operating system: Ubuntu 16.04 LTS</li>
<li>QEMU version: 2.6.0</li>
<li>Libvirt version: 1.3.5</li>
</ul>

<h3 id="tools">Tools</h3>

<p>The test suite consists of 3 main parts:</p>

<ol>
<li>Orchestration - <a href="https://github.com/timofei-durakov/orchestra">Orchestra</a></li>
<li>Metrics storage - <a href="https://www.influxdata.com/time-series-platform/influxdb/">Influxdb</a></li>
<li>Monitoring agents, - <a href="https://www.influxdata.com/time-series-platform/telegraf/">Telegraf</a> and <a href="https://github.com/rk4n/migration-monitor">migration monitor</a>.</li>
<li><a href="https://people.seas.harvard.edu/~apw/stress/">Stress</a> tool for dirtying the VM memory. ( example of cmdline parameters: <code>--vm 1 --vm-bytes 128M</code>. Number of workers and amount of memory per each.)</li>
</ol>

<p>Orchestra is responsible for managing instances during scenario run(boot, live-migrate, etc.), and also enabling/disabling monitoring. Ansible playbooks are used for update-config/setup up monitoring on hypervisor nodes or booted instances.</p>

<p>Influxdb is a time series database that is used for storing events from host hypervisors/instances.
Migration monitor - special tool that allows to capture events from libvirt to measure live-migration time, timeouts, dirty pages rate.</p>

<h3 id="test-scenarios">Test scenarios</h3>

<p>First set of scenarios is aimed to explore how different settings of auto-converge parameters affect the migration duration and outcome. For all tests we’ve used guest machines with 1 vCPU and 2Gb of RAM. As a baseline for load we’ve used 2 memory workers dirtying constantly 512Mb each, such load is sufficient to make default live migration last forever.</p>

<table>
<thead>
<tr>
<th align="center">#</th>
<th>Load</th>
<th>Auto-Converge params</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">1.</td>
<td>2 workers, <br/> 512Mb mem allocated</td>
<td><code>--auto-converge</code> <br/> default settings</td>
</tr>

<tr>
<td align="center">2.</td>
<td><em>same</em></td>
<td><code>--auto-converge</code> <br/> <code>x-cpu-throttle-initial 30</code> <br/> <code>x-cpu-throttle-increment 15</code></td>
</tr>

<tr>
<td align="center">3.</td>
<td><em>same</em></td>
<td><code>--auto-converge</code> <br/> <code>x-cpu-throttle-initial 50</code> <br/> <code>x-cpu-throttle-increment 20</code></td>
</tr>
</tbody>
</table>

<p><br/></p>

<p>Next part is to investigate post-copy related parameters:</p>

<table>
<thead>
<tr>
<th align="center">#</th>
<th>Load</th>
<th>Post-Copy params</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">4.</td>
<td>2 workers, <br/> 512Mb mem allocated</td>
<td><code>--auto-converge</code> <br/> <code>--timeout-postcopy</code> <br/> <code>--timeout 60</code></td>
</tr>

<tr>
<td align="center">5.</td>
<td><em>same</em></td>
<td><code>--postcopy</code> <br/> <code>--postcopy-after-precopy</code></td>
</tr>

<tr>
<td align="center">6.</td>
<td><em>same</em></td>
<td><code>--postcopy</code> <br/> <code>--postcopy-after-precopy</code> <br/> <code>--compressed</code></td>
</tr>
</tbody>
</table>

<p><br/></p>

<p>The difference between scenarios 4 and 5 is that by default QEMU uses pre-copy, and post-copy should be either triggered explicitly during the migration, or internally by timeout. Flag <code>--postcopy-after-precopy</code> indicates that post-copy step will be triggered after the first iteration of pre-copy. Flag <code>--timeout-postcopy</code> indicates that post-copy step will be automatically triggered after a timeout.</p>

<p>Next two scenarios define more aggressive load and aim to test both auto-converge and post-copy migrations under that load pattern.</p>

<table>
<thead>
<tr>
<th align="center">#</th>
<th>Load</th>
<th>Auto-Converge/Post-Copy params</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">7.</td>
<td>3 workers, <br/> 512Mb mem allocated</td>
<td><code>--auto-converge</code> <br/> <code>x-cpu-throttle-initial 50</code> <br/> <code>x-cpu-throttle-increment 20</code></td>
</tr>

<tr>
<td align="center">8.</td>
<td><em>same</em></td>
<td><code>--postcopy</code> <br/> <code>--postcopy-after-precopy</code></td>
</tr>
</tbody>
</table>

<p><br/></p>

<p>In conclusion we’re going to test how migration <code>max_downtime</code> parameter affects the live migration duration.</p>

<table>
<thead>
<tr>
<th align="center">#</th>
<th>Load</th>
<th>Post-Copy params</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">9.</td>
<td>3 workers, <br/> 512Mb mem allocated</td>
<td><code>--auto-converge</code> <br/> default settings</td>
</tr>

<tr>
<td align="center">10.</td>
<td><em>same</em></td>
<td><code>--auto-converge</code> <br/> <code>Migrate-setmaxdowntime 1000</code></td>
</tr>

<tr>
<td align="center">11.</td>
<td><em>same</em></td>
<td><code>--auto-converge</code> <br/> <code>Migrate-setmaxdowntime 5000</code></td>
</tr>
</tbody>
</table>

<p><br/></p>

<h2 id="test-results">Test Results</h2>

<p>Graphical examples of the Live migration with default auto-converge, customized auto-converge and default post-copy modes. Each figure has three graphs: migration duration, mem dirtying rate and remaining memory dynamics. Each figure shows 5 min timeframe to make it easier to reason about migration duration. Load pattern is the same: 2 workers with 512Mb allocated for dirtying.</p>

<p><img src="/img/qemu-lv-1/1.png" alt="Figure 1" />
<em>Figure 1 — default auto-converge</em>
<br/>
<br/></p>

<p><img src="/img/qemu-lv-1/2.png" alt="Figure 2" />
<em>Figure 2 — customized auto-converge (initial: 30%, increment: 15%)</em>
<br/>
<br/></p>

<p><img src="/img/qemu-lv-1/3.png" alt="Figure 3" />
<em>Figure 3 — post-copy</em>
<br/>
<br/></p>

<p>Test results for the first two sets of scenarios (auto-converge and post-copy with baseline load config):</p>

<p><img src="/img/qemu-lv-1/0_chart_0.png" alt="Figure 4" />
<em>Figure 4 — auto-converge and post-copy comparison chart</em>
<br/>
<br/></p>

<p>First three scenarios look pretty reasonable: QEMU with default settings for auto-converge migrates machine in 252 seconds, with more tough custom parameters migration time decreases. Scenario #4 showed slightly better results rather than #1 which requires some additional investigation, as QEMU should turn on post-copy (which we see in #5 and #6 is much faster compared to auto-converge) after 60 seconds.
<br/></p>

<p>Success rate for all scenarios except #6 is 100% :</p>

<table>
<thead>
<tr>
<th>Scenario</th>
<th>Success Rate</th>
</tr>
</thead>

<tbody>
<tr>
<td>1. default</td>
<td>100%</td>
</tr>

<tr>
<td>2. AC custom</td>
<td>100%</td>
</tr>

<tr>
<td>3. AC custom tough</td>
<td>100%</td>
</tr>

<tr>
<td>4. PC after 60s</td>
<td>100%</td>
</tr>

<tr>
<td>5. default PC</td>
<td>100%</td>
</tr>

<tr>
<td>6. PC with xbzrle</td>
<td>40%</td>
</tr>
</tbody>
</table>

<p>With increased load (3 workers, 512Mb allocated) situation is pretty the same for auto-converge and post-copy: auto-converge is much slower than post-copy.</p>

<p><img src="/img/qemu-lv-1/0_chart_1.png" alt="Figure 5" />
<em>Figure 5 — auto-converge and post-copy comparison chart for increased load</em>
<br/>
<br/></p>

<p>Final part is the comparison of different settings for <code>max_downtime</code> parameter. Greater <code>max_downtime</code> you have, less time to migrate you need.</p>

<p>Each figure shows <strong>7 min</strong> timeframe. Default <code>max_downtime</code> value for QEMU is 300(ms), according to QEMU source code (2.6.0 release branch).</p>

<p><img src="/img/qemu-lv-1/4.png" alt="Figure 6" />
<em>Figure 6 — Auto-converge with default <code>max_downtime</code> settings</em>
<br/>
<br/></p>

<p><img src="/img/qemu-lv-1/5.png" alt="Figure 7" />
<em>Figure 7 — Auto-converge with <code>max_downtime</code> set to 1000 (ms)</em></p>

<p>This is a less realistic scenario (<code>max_downtime = 5000ms</code>), it is shown just to compare it with 1000ms and 300ms. Better option is to use OpenStack Nova <code>force_complete</code> feature that allows heavy loaded machines that cannot be live-migrated to be paused during the migration.</p>

<p><img src="/img/qemu-lv-1/6.png" alt="Figure 8" />
<em>Figure 8 — Auto-converge with <code>max_downtime</code> set to 5000 (ms)</em>
<br/>
<br/></p>

<p>And summary chart looks like this:
<img src="/img/qemu-lv-1/0_chart_2.png" alt="Figure 9" />
<em>Figure 9 — auto-converge with different <code>max_downtime</code> settings</em>
<br/>
<br/></p>

<h2 id="conclusions">Conclusions</h2>

<p>We were aiming to compare results for live-migration using different configurations for auto-converge and post-copy. From the results above, we see that post-copy performs much better than other techniques, except when compression is used simultaneously. We suggest to use post-copy whenever possible, taking into account the increased risk of VM image corruption or loss. In other cases we recommend to use auto-converge.</p>

<h2 id="references">References</h2>

<p>The following materials were used:</p>

<ol>
<li>“Dive Into VM Live Migration” <a href="https://01.org/sites/default/files/dive_into_vm_live_migration_2.pdf">https://01.org/sites/default/files/dive_into_vm_live_migration_2.pdf</a></li>
<li>“Analysis of techniques for ensuring migration completion with KVM” <a href="https://www.berrange.com/posts/2016/05/12/analysis-of-techniques-for-ensuring-migration-completion-with-kvm/">https://www.berrange.com/posts/2016/05/12/analysis-of-techniques-for-ensuring-migration-completion-with-kvm/</a></li>
</ol>

	        </section>

	        <section class="post-tags" style="padding-bottom:60px;">
	            <div class="post-meta tags">
	            <i class="fa fa-fw fa-tag"></i>
	            
	            </div>
	        </section>
			
			
	        	<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'rk4n-gh-blog';
    var disqus_identifier = 'https:\/\/rk4n.github.io\/2016\/08\/10\/qemu-post-copy-and-auto-converge-features\/';
    var disqus_title = 'QEMU: Post-Copy and Auto-Converge features';
    var disqus_url = 'https:\/\/rk4n.github.io\/2016\/08\/10\/qemu-post-copy-and-auto-converge-features\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
	        
			
			

	        <section class="share">
	            <p class="backtotop"><a data-scroll href="#site-head"><i class="fa fa-lg fa-fw fa-angle-double-up"></i></a><a data-scroll class="backtotoptext" href="#site-head"> Back to top</a></p>
	            <p class="info prompt">Share</p>
	            <a href="http://twitter.com/share?text=QEMU%3a%20Post-Copy%20and%20Auto-Converge%20features&url=https%3a%2f%2frk4n.github.io%2f2016%2f08%2f10%2fqemu-post-copy-and-auto-converge-features%2f" title="Share on Twitter"
	                onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
	                <i class="fa fa-2x fa-fw fa-twitter-square"></i> <span class="hidden">Twitter</span>
	            </a>
	            <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2frk4n.github.io%2f2016%2f08%2f10%2fqemu-post-copy-and-auto-converge-features%2f" title="Share on Facebook"
	                onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
	                <i class="fa fa-2x fa-fw fa-facebook-square" style="margin-left: -8px"></i> <span class="hidden">Facebook</span>
	            </a>
	            <a href="https://plus.google.com/share?url=https%3a%2f%2frk4n.github.io%2f2016%2f08%2f10%2fqemu-post-copy-and-auto-converge-features%2f" title="Share on Google+"
	               onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
	                <i class="fa fa-2x fa-fw fa-google-plus-square" style="margin-left: -8px"></i> <span class="hidden">Google+</span>
	            </a>
	        </section>

	        <footer class="post-footer">
	            <section class="author">
    <div class="authorimage" style="background: url(https://rk4n.github.io/img/avatar.jpg)"></div>
    <h4>Vlad Nikityuk</h4>
    <p class="bio">Making things better.</p>
    <p class="meta">
      
    </p>
</section>
	        </footer>
	    </article>
	</main>

    <footer class="site-footer">
	<div class="inner">
		<section class="footer-social">
			
		    <a href="//twitter.com/rk4n" target="_blank" title="Twitter"><i class="fa fa-2x fa-fw fa-twitter"></i> <span class="hidden">Twitter</span></a>&nbsp;
		    
		    
		    <a href="//github.com/rk4n" target="_blank" title="GitHub"><i class="fa fa-2x fa-fw fa-github"></i> <span class="hidden">GitHub</span></a>&nbsp;
		    
		    <a href="" target="_blank" title="RSS"><i class="fa fa-2x fa-fw fa-rss"></i> <span class="hidden">RSS</span></a>
		</section>

		<section class="copyright">&copy; 2016 <a href="https://rk4n.github.io/">Vlad Nikityuk</a>. </section>
	</div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://rk4n.github.io/js/index.js"></script>
<script src="https://rk4n.github.io/js/smooth-scroll.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/highlight.min.js"></script>

<script>
    smoothScroll.init({
        speed: 800,
        easing: 'easeInOutCubic',
        updateURL: false,
        offset: 125,
    });
</script>
<script>hljs.initHighlightingOnLoad();</script>


<!-- Google Analytics -->
<script>
  var _gaq=[['_setAccount','UA-50360509-2'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>


</body>
</html>