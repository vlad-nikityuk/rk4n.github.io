<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title>QEMU: Post-Copy and Auto-Converge features &middot; Vlad&#39;s #dev blog</title>
    <meta name="author" content="Vlad Nikityuk">
    <meta name="description" content="Your description of the blog">
    <meta name="generator" content="Hugo 0.17-DEV" />
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <!-- RSS autodiscovery -->
    

    <link rel="shortcut icon" href="https://rk4n.github.io/img/favicon.ico">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/normalize/2.1.2/normalize.min.css">

    <!-- Stylesheets -->
    <link rel="stylesheet" href="https://rk4n.github.io/css/screen.css">
    <link rel="stylesheet" href="https://rk4n.github.io/css/github.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/styles/default.min.css">

    <!-- Stylesheet for theme color -->
    <style type="text/css">
    a, a:visited {color: #3498db;}
    .pagination a {color: #3498db;}
    .gist .gist-file .gist-meta a:visited {color: #3498db !important;}
    a:focus, a:hover {color: #2079b4;}
    h1.post-title a:focus, h1.post-title a:hover, h1.blog-title a:focus, h1.blog-title a:hover {color: #2079b4;}
    .older-posts:hover, .newer-posts:hover {color: #2079b4;}
</style>
</head>

<body class="post-template">

    <header id="site-head">
	
	<h1 class="blog-title"><a href="https://rk4n.github.io/">Vlad&rsquo;s #dev blog</a></h1>
	
	
	<h1 class="blog-subtitle">place for thoughts about tech</h1>
	
</header>
    
<nav class="menu" role="nav">
    <ul>
        
        	<li class="nav nav-current"><a href="/">Home</a></li>
      	
        	<li class="nav nav-current"><a href="/about/">About</a></li>
      	
    </ul>
</nav>


    <main class="content" role="main">
	    <article class="post">
	        <header>
	        <h1 class="post-title">QEMU: Post-Copy and Auto-Converge features</h1>
	        <div class="post-meta"><time datetime="10 August 2016">10 August 2016</time></div>
	        </header>

	        <section class="post-content">
	            

<p>Cloud lifecycle is a complex process that involves several procedures such as maintenance and upgrades. These operations mostly include migration of workloads. OpenStack provides several options to perform such moving:</p>

<ul>
<li>Cold migration</li>
<li>Live migrations</li>
<li>Instance rebuilds</li>
</ul>

<p>From the list above only live migration allows moving an instance from one host to another with almost zero downtime, which is done seamlessly for the instance itself.</p>

<p>In one of our previous researches we&rsquo;ve noticed that, by default, QEMU/KVM live migration has a pretty low <strong>convergence</strong> for heavy-loaded virtual machines. Convergence property reflects the ratio or difference between memory transfer speed and memory dirty speed during the live migration.</p>

<p>In this post, we&rsquo;re going to analyze different QEMU features that may help live migrations converge. The most important features are Post-Copy and Auto-Converge.</p>

<p><strong>Auto-Converge</strong> (AC). The idea behind auto-converge is pretty simple — by throttling down the virtual CPU execution time, the guest machine is prevented from dirtying memory faster than memory can be transferred over the wire. By default, QEMU throttles vCPU by 20% and increases throttling rate by 10% each iteration. This guarantees the that guest machine eventually migrates.</p>

<p><strong>Post-Copy</strong> (PC). The goal of post-copy is to transfer some portion of memory in normal pre-copy mode, then switch the guest to the destination node and request any missing memory pages on demand. This comes with the additional cost of waiting for a particular page to transfer from the source node, however, post-copy guarantees that guest migrates in a constant amount of time. The downside of using post-copy is that if the destination node fails or there is a network interruption, it becomes impossible to recover the guest machine state as it is distributed between the source and destination nodes.</p>

<p>We wanted to answer the following questions:</p>

<ol>
<li>How do various parameters of the post-copy and auto-converge features affect the migration outcome?</li>
<li>Does the migration <code>max_downtime</code> parameter have any impact on migration success?</li>
</ol>

<h1 id="test-harness">Test Harness</h1>

<h2 id="test-environment">Test Environment</h2>

<p>Our setup consists of two hypervisor nodes, one monitoring VM and workstation. The monitoring VM runs on a separate machine. Tests are executed from a workstation which is connected to the same network as monitoring VM and hypervisor machines.</p>

<p>All servers have the same configuration:</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>CPU</td>
<td>1x CPU Intel Xeon E3-1230, 3.20GHz, Socket 1155, 8MB Cache, 4 core, 80W</td>
</tr>

<tr>
<td>RAM</td>
<td>4x RAM 4GB Kingston KVR1333D3E9S/4GHB, DDR-III PC3-10600</td>
</tr>

<tr>
<td>Hard drive</td>
<td>2x HDD 1.5 TB, WD Caviar Black, WD1502FAEX, SATA 6.0 Gb/s, 7200 RPM, 64MB, 3.5”</td>
</tr>

<tr>
<td>Network</td>
<td>1x NIC AOC-CGP-i2, PCI-E x4, 2-port Gigabit Ethernet LAN</td>
</tr>
</tbody>
</table>

<p>Software versions:</p>

<ul>
<li>Operating system: Ubuntu 16.04 LTS</li>
<li>QEMU version: 2.6.0</li>
<li>Libvirt version: 1.3.5</li>
</ul>

<h2 id="tools">Tools</h2>

<p>The test suite consists of 3 main parts:</p>

<ol>
<li>Orchestration - <a href="https://github.com/timofei-durakov/orchestra">Orchestra</a></li>
<li>Metrics storage - <a href="https://www.influxdata.com/time-series-platform/influxdb/">Influxdb</a></li>
<li>Monitoring agents, - <a href="https://www.influxdata.com/time-series-platform/telegraf/">Telegraf</a> and <a href="https://github.com/rk4n/migration-monitor">migration monitor</a>.</li>
<li><a href="https://people.seas.harvard.edu/~apw/stress/">Stress</a> tool for dirtying the VM memory (example of cmdline parameters: <code>--vm 1 --vm-bytes 128M</code>. Number of workers and amount of memory per each).</li>
</ol>

<p>Orchestra is responsible for managing instances during scenario run (boot, live-migrate, etc.), and also enabling/disabling monitoring. Ansible playbooks are used for update-config/setup up monitoring on hypervisor nodes or booted instances.</p>

<p>Influxdb is a time series database that is used for storing events from host hypervisors/instances.
Migration monitor - a special tool that allows capturing events from libvirt to measure live-migration time, timeouts, dirty pages rate.</p>

<h2 id="test-scenarios">Test scenarios</h2>

<p>The first set of scenarios is aimed to explore how different settings of auto-converge parameters affect the migration duration and outcome. For all tests, we’ve used guest machines with 1 vCPU and 2Gb of RAM. As a baseline for the load we’ve used 2 memory workers dirtying constantly 512Mb each, such load is sufficient to make default live migration last forever.</p>

<h3 id="parameters-definitions">Parameters definitions</h3>

<ul>
<li><code>--auto-converge</code>: Enables auto-converge feature. The initial guest CPU throttling rate can be set with <code>auto-converge-initial</code>(or <code>x-cpu-throttle-initial</code>). If the initial throttling rate is not enough to ensure convergence, the rate is periodically increased by <code>auto-converge-increment</code>(<code>x-cpu-throttle-increment</code>).</li>

<li><p><code>x-cpu-throttle-initial</code> and <code>x-cpu-throttle-increment</code>: QEMU migration parameters specified via monitor command: <code>virsh qemu-monitor-command &lt;domain_name&gt; --hmp --cmd &quot;migration_set_parameter x-cpu-throttle-initial 50&quot;</code>.
According to <a href="http://wiki.qemu.org/Features/AutoconvergeLiveMigration">Features/AutoconvergeLiveMigration</a>, the initial throttling percentage defaults to 20%. If after a period of time the migration has still not completed then throttling is incremented. This process continues until migration completes or we reach 99% throttled. By default the throttling rate is always incremented by 10%.</p></li>

<li><p><code>--postcopy</code>: enables post-copy logic in migration, but does not actually start post-copy.</p></li>

<li><p><code>--postcopy-after-precopy</code>: let libvirt automatically switch to post-copy after the first pass of pre-copy is finished.</p></li>

<li><p><code>--compressed</code>: activates compression, the compression method is chosen with &ndash;comp-methods. Supported methods are &ldquo;mt&rdquo; and &ldquo;xbzrle&rdquo; and can be used in any combination. When no methods are specified, a hypervisor default methods will be used. QEMU defaults to &ldquo;xbzrle&rdquo;.</p></li>

<li><p><code>--timeout-postcopy</code>: When &ndash;timeout-postcopy is used, virsh will switch migration from pre-copy to post-copy upon timeout.</p></li>

<li><p><code>migrate-setmaxdowntime</code>: Set maximum tolerable downtime for a domain which is being live-migrated to another host.  The downtime is a number of milliseconds the guest is allowed to be down at the end of live migration.</p></li>
</ul>

<table>
<thead>
<tr>
<th align="center">#</th>
<th>Load</th>
<th>Auto-Converge params</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">1.</td>
<td>2 workers, <br/> 512Mb mem allocated</td>
<td><code>--auto-converge</code> <br/> <code>x-cpu-throttle-initial 20</code> <br/> <code>x-cpu-throttle-increment 10</code><br/><strong>default settings</strong>, see <a href="https://github.com/qemu/qemu/blob/507e4ddc3abf67391bcbc9624fd60b969c159b78/migration/migration.c#L55-L56">migration.c</a></td>
</tr>

<tr>
<td align="center">2.</td>
<td><em>same</em></td>
<td><code>--auto-converge</code> <br/> <code>x-cpu-throttle-initial 30</code> <br/> <code>x-cpu-throttle-increment 15</code></td>
</tr>

<tr>
<td align="center">3.</td>
<td><em>same</em></td>
<td><code>--auto-converge</code> <br/> <code>x-cpu-throttle-initial 50</code> <br/> <code>x-cpu-throttle-increment 20</code></td>
</tr>
</tbody>
</table>

<p>Next part is to investigate post-copy related parameters.
The difference between scenarios 4 and 5 is that by default QEMU uses pre-copy, and post-copy should be either triggered explicitly during the migration or internally by timeout. Flag <code>--postcopy-after-precopy</code> indicates that post-copy step will be triggered after the first iteration of pre-copy. Flag <code>--timeout-postcopy</code> indicates that post-copy step will be automatically triggered after a timeout.</p>

<table>
<thead>
<tr>
<th align="center">#</th>
<th>Load</th>
<th>Post-Copy params</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">4.</td>
<td>2 workers, <br/> 512Mb mem allocated</td>
<td><code>--auto-converge</code> <br/> <code>--timeout-postcopy</code> <br/> <code>--timeout 60</code></td>
</tr>

<tr>
<td align="center">5.</td>
<td><em>same</em></td>
<td><code>--postcopy</code> <br/> <code>--postcopy-after-precopy</code></td>
</tr>

<tr>
<td align="center">6.</td>
<td><em>same</em></td>
<td><code>--postcopy</code> <br/> <code>--postcopy-after-precopy</code> <br/> <code>--compressed</code></td>
</tr>
</tbody>
</table>

<p>Next two scenarios define more aggressive load and aim to test both auto-converge and post-copy migrations under that load pattern.</p>

<table>
<thead>
<tr>
<th align="center">#</th>
<th>Load</th>
<th>Auto-Converge/Post-Copy params</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">7.</td>
<td>3 workers, <br/> 512Mb mem allocated</td>
<td><code>--auto-converge</code> <br/> <code>x-cpu-throttle-initial 50</code> <br/> <code>x-cpu-throttle-increment 20</code></td>
</tr>

<tr>
<td align="center">8.</td>
<td><em>same</em></td>
<td><code>--postcopy</code> <br/> <code>--postcopy-after-precopy</code></td>
</tr>
</tbody>
</table>

<p><br/></p>

<p>Finally, we’re going to test how migration <code>max_downtime</code> parameter affects the live migration duration.</p>

<table>
<thead>
<tr>
<th align="center">#</th>
<th>Load</th>
<th>Post-Copy params</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">9.</td>
<td>3 workers, <br/> 512Mb mem allocated</td>
<td><code>--auto-converge</code> <br/> default settings</td>
</tr>

<tr>
<td align="center">10.</td>
<td><em>same</em></td>
<td><code>--auto-converge</code> <br/> <code>migrate-setmaxdowntime 1000</code></td>
</tr>

<tr>
<td align="center">11.</td>
<td><em>same</em></td>
<td><code>--auto-converge</code> <br/> <code>migrate-setmaxdowntime 5000</code></td>
</tr>
</tbody>
</table>

<p><br/></p>

<h1 id="test-results">Test Results</h1>

<p>Graphical examples of the Live migration with default auto-converge, customized auto-converge and default post-copy modes. Each figure has three graphs: migration duration, mem dirtying rate, and remaining memory dynamics. Each figure shows 5 min timeframe to make it easier to reason about migration duration. Load pattern is the same: 2 workers with 512Mb allocated for dirtying.</p>

<p><img src="/img/qemu-lv-1/1.png" alt="Figure 1" />
<em>Figure 1 — default auto-converge</em>
<br/>
<br/></p>

<p><img src="/img/qemu-lv-1/2.png" alt="Figure 2" />
<em>Figure 2 — customized auto-converge (initial: 30%, increment: 15%)</em>
<br/>
<br/></p>

<p><img src="/img/qemu-lv-1/3.png" alt="Figure 3" />
<em>Figure 3 — post-copy</em>
<br/>
<br/></p>

<p>Test results for the first two sets of scenarios (auto-converge and post-copy with baseline load config):</p>

<p><img src="/img/qemu-lv-1/0_chart_0.png" alt="Figure 4" />
<em>Figure 4 — auto-converge and post-copy comparison chart</em>
<br/>
<br/></p>

<p>First three scenarios look pretty reasonable: QEMU with default settings for auto-converge migrates machine in 252 seconds, with more tough custom parameters migration time decreases. Scenario #4 showed slightly better results rather than #1 which requires some additional investigation, as QEMU should turn on post-copy (which we see in #5 and #6 is much faster compared to auto-converge) after 60 seconds.
<br/></p>

<p>Success rate for all scenarios except #6 is 100% :</p>

<table>
<thead>
<tr>
<th>Scenario</th>
<th>Success Rate</th>
</tr>
</thead>

<tbody>
<tr>
<td>1. default</td>
<td>100%</td>
</tr>

<tr>
<td>2. AC custom</td>
<td>100%</td>
</tr>

<tr>
<td>3. AC custom tough</td>
<td>100%</td>
</tr>

<tr>
<td>4. PC after 60s</td>
<td>100%</td>
</tr>

<tr>
<td>5. default PC</td>
<td>100%</td>
</tr>

<tr>
<td>6. PC with xbzrle</td>
<td>40%</td>
</tr>
</tbody>
</table>

<p>With increased load (3 workers, 512Mb allocated) situation is pretty the same for auto-converge and post-copy: auto-converge is much slower than post-copy.</p>

<p><img src="/img/qemu-lv-1/0_chart_1.png" alt="Figure 5" />
<em>Figure 5 — auto-converge and post-copy comparison chart for increased load</em>
<br/>
<br/></p>

<p>The final part is the comparison of different settings for the <code>max_downtime</code> parameter. Greater <code>max_downtime</code> you have, less time to migrate you need.</p>

<p>Each figure shows <strong>7 min</strong> timeframe. Default <code>max_downtime</code> value for QEMU is 300(ms), according to QEMU source code (2.6.0 release branch).</p>

<p><img src="/img/qemu-lv-1/4.png" alt="Figure 6" />
<em>Figure 6 — Auto-converge with default <code>max_downtime</code> settings</em>
<br/>
<br/></p>

<p><img src="/img/qemu-lv-1/5.png" alt="Figure 7" />
<em>Figure 7 — Auto-converge with <code>max_downtime</code> set to 1000 (ms)</em></p>

<p>This is a less realistic scenario (<code>max_downtime = 5000ms</code>), it is shown just to compare it with 1000ms and 300ms. A better option is to use OpenStack Nova <code>force_complete</code> feature that allows heavy loaded machines that cannot be live-migrated to be paused during the migration.</p>

<p><img src="/img/qemu-lv-1/6.png" alt="Figure 8" />
<em>Figure 8 — Auto-converge with <code>max_downtime</code> set to 5000 (ms)</em>
<br/>
<br/></p>

<p>And summary chart looks like this:
<img src="/img/qemu-lv-1/0_chart_2.png" alt="Figure 9" />
<em>Figure 9 — auto-converge with different <code>max_downtime</code> settings</em>
<br/>
<br/></p>

<h1 id="conclusions">Conclusions</h1>

<p>Our aim was a comparison of different live migration techniques under various configuration parameters, in order to demonstrate and recommend an appropriate usage of post-copy and auto-converge.</p>

<p>From the results above, we see that post-copy performs much better than other techniques, except when compression is used simultaneously. It&rsquo;s actually not quite true, because during the post-copy phase VM performance degrades significantly, which was not measured.</p>

<p>Both, auto-converge and post-copy, perform very well. In case you don’t want to lose your data don’t use post-copy. Something that still needs a research is how post-copy impacts workload running on a VM and a comparison of that with how auto-converge impacts the workload.</p>

<h1 id="references">References</h1>

<p>The following materials were used:</p>

<ol>
<li>“Dive Into VM Live Migration” <a href="https://01.org/sites/default/files/dive_into_vm_live_migration_2.pdf">https://01.org/sites/default/files/dive_into_vm_live_migration_2.pdf</a></li>
<li>“Analysis of techniques for ensuring migration completion with KVM” <a href="https://www.berrange.com/posts/2016/05/12/analysis-of-techniques-for-ensuring-migration-completion-with-kvm/">https://www.berrange.com/posts/2016/05/12/analysis-of-techniques-for-ensuring-migration-completion-with-kvm/</a></li>
</ol>

	        </section>

	        <section class="post-tags" style="padding-bottom:60px;">
	            <div class="post-meta tags">
	            <i class="fa fa-fw fa-tag"></i>
	            
	            </div>
	        </section>
			
			
	        	<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'rk4n-gh-blog';
    var disqus_identifier = 'https:\/\/rk4n.github.io\/2016\/08\/10\/qemu-post-copy-and-auto-converge-features\/';
    var disqus_title = 'QEMU: Post-Copy and Auto-Converge features';
    var disqus_url = 'https:\/\/rk4n.github.io\/2016\/08\/10\/qemu-post-copy-and-auto-converge-features\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
	        
			
			

			
	        
	        
	        
	    </article>
	</main>

    <footer class="site-footer">
	<div class="inner">
		<section class="footer-social">
			
		    <a href="//twitter.com/rk4n" target="_blank" title="Twitter"><i class="fa fa-2x fa-fw fa-twitter"></i> <span class="hidden">Twitter</span></a>&nbsp;
		    
		    
		    <a href="//github.com/rk4n" target="_blank" title="GitHub"><i class="fa fa-2x fa-fw fa-github"></i> <span class="hidden">GitHub</span></a>&nbsp;
		    
		    <a href="" target="_blank" title="RSS"><i class="fa fa-2x fa-fw fa-rss"></i> <span class="hidden">RSS</span></a>
		</section>

		<section class="copyright">&copy; 2016 <a href="https://rk4n.github.io/">Vlad Nikityuk</a>. </section>
	</div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://rk4n.github.io/js/index.js"></script>
<script src="https://rk4n.github.io/js/smooth-scroll.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/highlight.min.js"></script>

<script>
    smoothScroll.init({
        speed: 800,
        easing: 'easeInOutCubic',
        updateURL: false,
        offset: 125,
    });
</script>
<script>hljs.initHighlightingOnLoad();</script>


<!-- Google Analytics -->
<script>
  var _gaq=[['_setAccount','UA-50360509-2'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>


</body>
</html>